function [Xsol, ysol, primalObj, dualObj, terminateReason, time] = ...
    pcp3(C, A, b, opt)
% PCP implements polyhedral cutting plane algorithm for solving the
% following SDP problem:
%            min_X <C,X>
%       subject to <Ai,X>=bi  i = 1 ... m
%                   X >= 0
% Arguments:
%    C: n x n symmetric matrix
%    A: m x n x n, linear operator consisting of m nxn symmetric matrices
%       trace(A(i, :, :).' * X) = b(i) is <Ai,X>=bi for i=1...m
%    b: right-hand-side vector of the equality constrraint
%    opt: options generated by pcpOptions

opt.logDir = sprintf('%s3', opt.logDir);

if opt.record
    diary off;
    % create folder
    logDir = fullfile([opt.logDir, filesep, opt.logName]);
    if ~isfolder(logDir)
        mkdir(logDir);
    end
    % open diary
    opt.logDiaryFile = fullfile([logDir, filesep, 'diary.txt']);
    opt.logDataFile = fullfile([logDir, filesep, 'data.mat']);
    if isfile(opt.logDiaryFile)
        delete(opt.logDiaryFile);
    end
    diary(opt.logDiaryFile);

    logData = struct;
    fields = {'DSize'; 'UB'; 'LB'; 'S11'; 'primalObj'; 'dualObj'};
    for i = 1 : size(fields)
        logData.(fields{i}) = {};
    end
end

warning(opt.debug);
terminateReason = 'MAXITR';
Xsol = []; primalObj = []; dualObj = [];
tstart = tic;

%% Initialization
n = size(C, 1); m = size(A, 1);
UB = inf; LB = inf;
k = 0;

options = sdpsettings('verbose', 0, 'solver', 'mosek', ...
    'savesolveroutput', 1);

% this may fail because the feasible set may be empty!
% ybar = sdpvar(m, 1);
% a = b' * ybar;
% optimize(linearOpT(A, ybar) == eye(n), b' * ybar, options);
% a = value(a);

% this makes linearOpT(A, ybar) == eye(n) satisfied at least square error
ybar = linearOpT2mat(A) \ vec(eye(n));
a = ybar.' * b;

% y = sdpvar(m, 1);
% Z = C - linearOpT(A, y);
% D = eye(n);
% cons = [];
% for i = 1 : size(D, 1)
%     v = D(:, i);
%     cons = [cons, (v' * Z * v >= 0):sprintf('k=%d-%d', k, i)]; %#ok<AGROW>
% end
% cost = b' * y;

y = sdpvar(m, 1); % k=0
Z = C - linearOpT(A, y);
sol = optimize(diag(Z) >= 0, -b' * y, options);
Z = value(Z);
y = value(y);
if sol.problem ~= 0 || any(isnan(Z), 'all') || any(isnan(y))
    y = rand(m, 1);
    Z = C - linearOpT(A, y);
end
% while true
%     [~, lam] = safeSmallestEigs(Z, 1);
%     if size(lam, 1) < 1
%         disp('Fail to initialize y0.');
%         endRecord();
%         return;
%     end
%     if lam > -1e-6
%         break;
%     end
%     lam = abs(lam(1, 1));
%     y = y - lam * ybar;
%     Z = C - linearOpT(A, y);
% end
% Z = Z + lam * eye(n);
% yhatk = yk;
[D, ~] = eig(full(Z));
x = sdpvar(size(D, 2), 1);
Xsol = D * diag(x) * D';
cost = sum(C .* Xsol, 'all');
cons = [x >= 0, b == linearOp(A, Xsol)];
optimize(cons, cost, options);
x = value(x);
[x, ind] = sort(x, 'descend');
D = D(:, ind);
R1 = 20;
R3 = 20;
R2 = size(D, 2) - R3;
opt.s = 10;
P1 = D(:, 1:R1);
P2 = D(:, R1+1:R2);
P3 = D(:, R2+1:end);

Xsol = value(Xsol);
primalObj = value(cost);

disp(primalObj);
disp(sum(x));
disp(sum(x(R1+1:end)));

V1var = sdpvar(R1, R1, 'symmetric');
V3var = sdpvar(R3, R3, 'symmetric');
xxvar = sdpvar(size(P2, 2), 1);

while opt.maxItr < 0 || k < opt.maxItr
%% Update UB
Xsol = P1 * V1var * P1' + P2 * diag(xxvar) * P2' + P3 * V3var * P3';
cost = sum(C .* Xsol, 'all');
cons = [xxvar >= 0, V1var >= 0, V3var >= 0, ...
    (b == linearOp(A, Xsol)):'equality'];
assign(V1var, diag(x(1:R1))); assign(xxvar, x(R1+1:R2)); 
assign(V3var, diag(x(R2+1:end)));
sol = optimize(cons, cost, options);

xx = value(xxvar);
V1 = value(V1var);
V3 = value(V3var);
Xsol = value(Xsol);
ysol = value(dual(cons('equality')));
Zsol = C - linearOpT(A, ysol);
primalObj = value(cost);
dualObj = b' * ysol;
costVal = dualObj;

[Pnew, S] = safeSmallestEigs(Zsol, opt.s);
if size(S, 1) < opt.s
    terminateReason = 'EIGS FAILURE';
    break;  % failed
end
Pnew = Pnew(:, 1:opt.s);

[Q1, L1] = eig(V1); l1 = diag(L1);
[Q3, L3] = eig(V3); l3 = diag(L3);
P = [P1 * Q1, P2, P3 * Q3];
[x, ind] = sort([l1; xx; l3], 'descend');
P = P(:, ind);
P1 = P(:, 1:R1);
P2 = P(:, R1+1:R2);
P3 = P(:, R2+1:end - opt.s);
[P3, ~] = qr([P3, Pnew], 0);
dn = R3 - size(P3, 2);
if size(P3, 2) < R3
    P3 = [P3, P2(:, 1:dn)]; %#ok<AGROW> 
end

% x = sdpvar(size(D, 2), 1);
% Xsol = D * diag(x) * D';
% cost = sum(C .* Xsol, 'all');
% cons = [x >= 0, (b == linearOp(A, Xsol)):'equality'];
% optimize(cons, cost, options);
% x = value(x);
% y = value(dual(cons('equality')));
% ysol = y;
% ZVal = C - linearOpT(A, y);
% costVal = b' * y;
% dualObj = costVal;
% Xsol = value(Xsol);
% primalObj = value(cost);

% optimize(cons, -cost, options);
% costVal = value(cost);
% ZVal = value(Z);
UB = min(UB, costVal);
% x = dual(cons);
% x = value(x);
% Xsol = D * diag(x) * D';
% primalObj = full(sum(C .* Xsol, 'all'));
% ysol = value(y);
% dualObj = value(cost);

%% Update LB
% [V, S] = safeSmallestEigs(ZVal, opt.s);
% if size(S, 1) < 1
%     terminateReason = 'EIGS FAILURE';
%     break;  % failed
% end
% nn = min([opt.s, size(V, 2)]);
% V = V(:, 1:nn);
% S = S(:, 1:nn);

lam = abs(S(1, 1));
LB = min(LB, costVal + a * lam);

% log
fprintf('%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\n', k, primalObj, dualObj, UB, LB, S(1, 1), min(xx), max(xx), sum(xx), trace(V1), trace(V3));
% fprintf('%d\t%f\t%f\t%f\t%f\t%f\n', k, primalObj, dualObj, UB, LB, S(1, 1));
if opt.record
    logData.DSize{k+1} = size(D);
    logData.UB{k+1} = UB;
    logData.LB{k+1} = LB;
    logData.S11{k+1} = S(1, 1);
    logData.primalObj{k+1} = primalObj;
    logData.dualObj{k+1} = dualObj;
end

if (abs(LB - UB) < opt.epsilon1) || (lam < opt.epsilon2)
    terminateReason = 'CONVERGE';
    break;  % converged
end

%% Update Constraints
% drop existing constraints
% [xSorted, ind] = sort(x, 'ascend');
% x = xSorted;
% D = D(:, ind);
% mask = x < max(x) * 1e-6;
%
% if any(mask)
% %     D = D(:, ~mask);
%     r0 = size(mask, 1);
%     r1 = size(D, 2);
%     fprintf('%f\t%f\t%d\t%d\n', min(x), max(x), r0, r1);
% else
%     fprintf('%f\t%f\n', min(x), max(x));
% end
% % for i = 1 : size(V, 2)
% %     v = V(:, i);
% %     cons = [cons, (v' * Z * v >= 0):sprintf('k=%d-%d', k, i)]; %#ok<AGROW>
% % end
% D = [D, V]; %#ok<AGROW>

k = k + 1;

end % while

time = toc(tstart);

%% Termination
fprintf('%s after %d sec\n', terminateReason, time);

if opt.record
    diary off;
    clear('cons', 'Z');
    if isfile(opt.logDataFile)
        delete(opt.logDataFile);
    end
    save(opt.logDataFile);
end

warning on;
end
