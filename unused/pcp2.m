function [Xsol, ysol, primalObj, dualObj, terminateReason, time] = ...
    pcp2(C, A, b, opt)
% PCP implements polyhedral cutting plane algorithm for solving the
% following SDP problem:
%            min_X <C,X>
%       subject to <Ai,X>=bi  i = 1 ... m
%                   X >= 0
% Arguments:
%    C: n x n symmetric matrix
%    A: m x n x n, linear operator consisting of m nxn symmetric matrices
%       trace(A(i, :, :).' * X) = b(i) is <Ai,X>=bi for i=1...m
%    b: right-hand-side vector of the equality constrraint
%    opt: options generated by pcpOptions

if opt.record
    diary off;
    % create folder
    logDir = fullfile([opt.logDir, filesep, opt.logName]);
    if ~isfolder(logDir)
        mkdir(logDir);
    end
    % open diary
    opt.logDiaryFile = fullfile([logDir, filesep, 'diary.txt']);
    opt.logDataFile = fullfile([logDir, filesep, 'data.mat']);
    if isfile(opt.logDiaryFile)
        delete(opt.logDiaryFile);
    end
    diary(opt.logDiaryFile);

    logData = struct;
    fields = {'DSize'; 'UB'; 'LB'; 'S11'; 'primalObj'; 'dualObj'};
    for i = 1 : size(fields)
        logData.(fields{i}) = {};
    end
end

warning(opt.debug);
terminateReason = 'MAXITR';
Xsol = []; primalObj = []; dualObj = [];
tstart = tic;

%% Initialization
n = size(C, 1); m = size(A, 1);
UB = inf; LB = inf;
k = 0;

options = sdpsettings('verbose', 0, 'solver', 'mosek', ...
    'savesolveroutput', 1);

% this may fail because the feasible set may be empty!
% ybar = sdpvar(m, 1);
% a = b' * ybar;
% optimize(linearOpT(A, ybar) == eye(n), b' * ybar, options);
% a = value(a);

% this makes linearOpT(A, ybar) == eye(n) satisfied at least square error
ybar = linearOpT2mat(A) \ vec(eye(n));
a = ybar.' * b;

% y = sdpvar(m, 1);
% Z = C - linearOpT(A, y);
D = eye(n);
% cons = [];
% for i = 1 : size(D, 1)
%     v = D(:, i);
%     cons = [cons, (v' * Z * v >= 0):sprintf('k=%d-%d', k, i)]; %#ok<AGROW>
% end
% cost = b' * y;

y = sdpvar(m, 1); % k=0
Z = C - linearOpT(A, y);
sol = optimize(diag(Z) >= 0, -b' * y, options);
Z = value(Z);
y = value(y);
if sol.problem ~= 0 || any(isnan(Z), 'all') || any(isnan(y))
    y = rand(m, 1);
    Z = C - linearOpT(A, y);
    while true
        [~, lam] = safeSmallestEigs(Z, 1);
        if size(lam, 1) < 1
            disp('Fail to initialize y0.');
            endRecord();
            return;
        end
        if lam > -1e-6
            break;
        end
        lam = abs(lam(1, 1));
        y = y - lam * ybar;
        Z = C - linearOpT(A, y);
    end
end
% Z = Z + lam * eye(n);
% yhatk = yk;
[D, ~] = eig(full(Z));
x = sdpvar(size(D, 2), 1);
Xsol = D * diag(x) * D';
cost = sum(C .* Xsol, 'all');
cons = [x >= 0, b == linearOp(A, Xsol)];
optimize(cons, cost, options);
x = value(x);
[x, ind] = sort(x, 'ascend');
D = D(:, ind);
R1 = 25;
R2 = R1 - opt.s;
P = D(:, 1:R1);
D = D(:, R1+1:end);

Xsol = value(Xsol);
primalObj = value(cost);

disp(primalObj);
disp(sum(x));
disp(sum(x(R1+1:end)));

while opt.maxItr < 0 || k < opt.maxItr
%% Update UB
V = sdpvar(R1, R1, 'symmetric');
aa = sdpvar(size(D, 2), 1);
Xsol = D * diag(aa) * D' + P * V * P';
cost = sum(C .* Xsol, 'all');
cons = [aa >= 0, V >= 0, (b == linearOp(A, Xsol)):'equality'];
sol = optimize(cons, cost, options);

aa = value(aa);
V = value(V);
Xsol = value(Xsol);
ysol = value(dual(cons('equality')));
Zsol = C - linearOpT(A, ysol);
primalObj = value(cost);
dualObj = b' * ysol;
costVal = dualObj;

[Pnew, S] = safeSmallestEigs(Zsol, opt.s);
if size(S, 1) < opt.s
    terminateReason = 'EIGS FAILURE';
    break;  % failed
end

[Q, L] = eig(V);
[l, ind] = sort(diag(L), 'ascend'); Q = Q(:, ind);
Q1 = Q(:, 1:R2);
Q2 = Q(:, R2+1:end); L2 = diag(l(R2+1:end));
PQ2 = P * Q2;
mask = aa > max(aa) * 1e-3;
D = D(:, mask);
D = [D, PQ2];
% W = aa * W + PQ2 * L2 * PQ2'; W = W / trace(W);
[P, ~] = qr([P * Q1, Pnew], 0);

% x = sdpvar(size(D, 2), 1);
% Xsol = D * diag(x) * D';
% cost = sum(C .* Xsol, 'all');
% cons = [x >= 0, (b == linearOp(A, Xsol)):'equality'];
% optimize(cons, cost, options);
% x = value(x);
% y = value(dual(cons('equality')));
% ysol = y;
% ZVal = C - linearOpT(A, y);
% costVal = b' * y;
% dualObj = costVal;
% Xsol = value(Xsol);
% primalObj = value(cost);

% optimize(cons, -cost, options);
% costVal = value(cost);
% ZVal = value(Z);
UB = min(UB, costVal);
% x = dual(cons);
% x = value(x);
% Xsol = D * diag(x) * D';
% primalObj = full(sum(C .* Xsol, 'all'));
% ysol = value(y);
% dualObj = value(cost);

%% Update LB
% [V, S] = safeSmallestEigs(ZVal, opt.s);
% if size(S, 1) < 1
%     terminateReason = 'EIGS FAILURE';
%     break;  % failed
% end
% nn = min([opt.s, size(V, 2)]);
% V = V(:, 1:nn);
% S = S(:, 1:nn);

lam = abs(S(1, 1));
LB = min(LB, costVal + a * lam);

% log
fprintf('%d\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%d\n', k, primalObj, dualObj, UB, LB, S(1, 1), min(aa), max(aa), trace(V), size(D, 2));
% fprintf('%d\t%f\t%f\t%f\t%f\t%f\n', k, primalObj, dualObj, UB, LB, S(1, 1));
if opt.record
    logData.DSize{k+1} = size(D);
    logData.UB{k+1} = UB;
    logData.LB{k+1} = LB;
    logData.S11{k+1} = S(1, 1);
    logData.primalObj{k+1} = primalObj;
    logData.dualObj{k+1} = dualObj;
end

if (abs(LB - UB) < opt.epsilon1) || (lam < opt.epsilon2)
    terminateReason = 'CONVERGE';
    break;  % converged
end

%% Update Constraints
% drop existing constraints
% [xSorted, ind] = sort(x, 'ascend');
% x = xSorted;
% D = D(:, ind);
% mask = x < max(x) * 1e-6;
%
% if any(mask)
% %     D = D(:, ~mask);
%     r0 = size(mask, 1);
%     r1 = size(D, 2);
%     fprintf('%f\t%f\t%d\t%d\n', min(x), max(x), r0, r1);
% else
%     fprintf('%f\t%f\n', min(x), max(x));
% end
% % for i = 1 : size(V, 2)
% %     v = V(:, i);
% %     cons = [cons, (v' * Z * v >= 0):sprintf('k=%d-%d', k, i)]; %#ok<AGROW>
% % end
% D = [D, V]; %#ok<AGROW>

k = k + 1;

end % while

time = toc(tstart);

%% Termination
fprintf('%s after %d sec\n', terminateReason, time);

if opt.record
    diary off;
    clear('cons', 'Z');
    if isfile(opt.logDataFile)
        delete(opt.logDataFile);
    end
    save(opt.logDataFile);
end

warning on;
end
