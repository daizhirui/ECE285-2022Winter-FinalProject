function out = pcp(C, A, b, opt)
% PCP implements polyhedral cutting plane algorithm for solving the
% following SDP problem:
%            min_X <C,X>
%       subject to <Ai,X>=bi  i = 1 ... m
%                   X >= 0
% Arguments:
%    C: n x n symmetric matrix
%    A: m x n x n, linear operator consisting of m nxn symmetric matrices
%       trace(A(i, :, :).' * X) = b(i) is <Ai,X>=bi for i=1...m
%    b: right-hand-side vector of the equality constrraint
%    opt: options generated by sbmOptions

function prepareRecord()
    diary off;
    % create folder
    logDir = fullfile([opt.logDir, filesep, opt.logName]);
    if ~isfolder(logDir)
        mkdir(logDir);
    end
    % open diary
    opt.logDiaryFile = fullfile([logDir, filesep, 'diary.txt']);
    opt.wsDataFile = fullfile([logDir, filesep, 'wsData.mat']);
    opt.logDataFile = fullfile([logDir, filesep, 'logData.mat']);
    if isfile(opt.logDiaryFile)
        delete(opt.logDiaryFile);
    end
    diary(opt.logDiaryFile);
end

function endRecord()
    if opt.record
        diary off;
        clear('cons', 'Z');
        if isfile(opt.wsDataFile)
            delete(opt.wsDataFile);
        end
        if isfile(opt.logDataFile)
            delete(opt.logDataFile);
        end
        % save out.logData in a separate file because it may be very large
        logData = out.logData;
        save(opt.logDataFile, 'logData', '-v7.3');
        clear('logData');
        out = rmfield(out, 'logData'); % remove logData
        save(opt.wsDataFile, '-v7.3'); % save the workspace
    end
end

ME.ASSUM3 = MException('SBM:ASSUM3', '"A^T(ybar) = I" cannot hold.');
ME.INIT_Y0 = MException('SBM:INIT_Y0', 'Failed to initialize y0.');
ME.SOLVER_FAILURE = MException('SBM:SOLVER', 'Solver Failure.');
ME.EIGS_FAILURE = MException('SBM:EIGS', 'safeSmallestEigs Failure.');

try

out.alg = 'pcp';
if opt.record
    prepareRecord();
    out.logData = struct;
    fields = {'DSize'; 'UB'; 'LB'; 'S11'; 'primalObj'; 'dualObj'; 'time'};
    for i = 1 : size(fields)
        out.logData.(fields{i}) = {};
    end
end

warning(opt.debug);
out.info = 'MAXITR'; out.totalTime = -1;
out.Xsol = []; out.ysol = []; out.primalObj = -inf; out.dualObj = inf;
out.solverOutput = []; out.dualGap = inf; out.problem = 0;
tstart = tic;

%% Initialization
n = size(C, 1); m = size(A, 1); UB = inf; LB = inf; k = 0;

options = sdpsettings('verbose', 0, 'solver', 'mosek', ...
    'savesolveroutput', 1);

% this may fail because the feasible set may be empty!
% ybar = sdpvar(m, 1);
% a = b' * ybar;
% optimize(linearOpT(A, ybar) == eye(n), b' * ybar, options);
% a = value(a);

% this makes linearOpT(A, ybar) == eye(n) satisfied at least square error
ybar = linearOpT2mat(A) \ vec(eye(n));
a = ybar.' * b;
out.opt = opt;

D = eye(n);
y = sdpvar(m, 1);
Z = C - linearOpT(A, y);
cons = [];
for i = 1 : size(D, 1)
    v = D(:, i);
    cons = [cons, (v' * Z * v >= 0):sprintf('k=%d-%d', k, i)]; %#ok<AGROW>
end
cost = b' * y;

while opt.maxItr < 0 || k < opt.maxItr
%% Update UB
sol = optimize(cons, -cost, options);
time = toc(tstart);
costVal = value(cost);
ZVal = value(Z);
if sol.problem == 0
    UB = min(UB, costVal);
end
x = dual(cons);
x = value(x);
out.Xsol = D * diag(x) * D';
out.ysol = value(y);
out.primalObj = full(sum(C .* out.Xsol, 'all'));
out.dualObj = value(cost);
out.dualGap = out.primalObj - out.dualObj;

%% Update LB
[V, S] = safeSmallestEigs(ZVal, opt.s);
if size(S, 1) < 1
	throw(ME.EIGS_FAILURE);
end
nn = min([opt.s, size(V, 2)]);
V = V(:, 1:nn);
S = S(:, 1:nn);

lam = abs(S(1, 1));
if sol.problem == 0
    LB = min(LB, costVal + a * lam);
end

% log
fprintf('%d\t%f\t%f\t%f\t%f\t%f\n', ...
    k, out.primalObj, out.dualObj, UB, LB, S(1, 1));
if opt.record
    out.logData.DSize{k+1} = size(D);
    out.logData.UB{k+1} = UB;
    out.logData.LB{k+1} = LB;
    out.logData.S11{k+1} = S(1, 1);
    out.logData.primalObj{k+1} = out.primalObj;
    out.logData.dualObj{k+1} = out.dualObj;
    out.logData.time{k+1} = time;
end

if (abs(LB - UB) < opt.epsilon1) || (lam < opt.epsilon2)
    out.info = 'CONVERGE';
    break;
end

%% Update Constraints
for i = 1 : size(V, 2)
    v = V(:, i);
    cons = [cons, (v' * Z * v >= 0):sprintf('k=%d-%d', k, i)]; %#ok<AGROW>
end
D = [D, V]; %#ok<AGROW>

k = k + 1;

end % while

%% Termination
out.dualGap = out.primalObj - out.dualObj;
out.primalRes = sum(linearOp(A, out.Xsol) - b, 'all');
out.totalTime = toc(tstart);

fprintf('Report:\n');
fprintf('%s after %d sec\n', out.info, out.totalTime);
fprintf('primal Obj. = %.6e\n', out.primalObj);
fprintf('dual Obj. = %.6e\n', out.dualObj);
fprintf('dual Gap = %.6e (%f%%)\n', out.dualGap, ...
    out.dualGap / abs(out.dualObj) * 100);
fprintf('primal Res. = %.6e\n', out.primalRes);

catch ME
    out.info = ME.message;
    out.problem = 1;

    out.primalRes = sum(linearOp(A, out.Xsol) - b, 'all');
    out.totalTime = toc(tstart);

    if strcmp(opt.debug, 'on')
        rethrow(ME)
    else
        disp(ME.message);
    end
end

endRecord();
warning on;

end
