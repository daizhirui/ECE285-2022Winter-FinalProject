function out = pbs(C, A, b, opt)
% PBS implements polyhedral bundle scheme algorithm for solving the
% following SDP problem:
%            min_X <C,X>
%       subject to <Ai,X>=bi  i = 1 ... m
%                   X >= 0
% Arguments:
%    C: n x n symmetric matrix
%    A: m x n x n, linear operator consisting of m nxn symmetric matrices
%       trace(A(i, :, :).' * X) = b(i) is <Ai,X>=bi for i=1...m
%    b: right-hand-side vector of the equality constrraint
%    opt: options generated by sbmOptions

function prepareRecord()
    if opt.record
        diary off;
        % create folder
        logDir = fullfile([opt.logDir, filesep, opt.logName]);
        if ~isfolder(logDir)
            mkdir(logDir);
        end
        % open diary
        opt.logDiaryFile = fullfile([logDir, filesep, 'diary.txt']);
        opt.wsDataFile = fullfile([logDir, filesep, 'wsData.mat']);
        opt.logDataFile = fullfile([logDir, filesep, 'logData.mat']);
        if isfile(opt.logDiaryFile)
            delete(opt.logDiaryFile);
        end
        diary(opt.logDiaryFile);
    
        out.logData = struct;
        for ii = 1 : size(fields)
            out.logData.(fields{ii}) = {};
        end
    end
end

function endRecord()
    if opt.record
        diary off;
        clear('cons', 'Z', 'gamma', 'reg', 'XZk');
        if isfile(opt.wsDataFile)
            delete(opt.wsDataFile);
        end
        if isfile(opt.logDataFile)
            delete(opt.logDataFile);
        end
        % save out.logData in a separate file because it may be very large
        logData = out.logData;
        save(opt.logDataFile, 'logData', '-v7.3');
        clear('logData');
        out = rmfield(out, 'logData'); % remove logData
        save(opt.wsDataFile, '-v7.3'); % save the workspace
    end
end

ME.ASSUM3 = MException('SBM:ASSUM3', '"A^T(ybar) = I" cannot hold.');
ME.INIT_Y0 = MException('SBM:INIT_Y0', 'Failed to initialize y0.');
ME.OPT_S = MException('SBM:OPT_S', ...
        's=%d may be too large for the problem data.\n', opt.s);
ME.SOLVER_FAILURE = MException('SBM:SOLVER', 'Solver Failure.');
ME.EIGS_FAILURE = MException('SBM:EIGS', 'safeSmallestEigs Failure.');

try

out.alg = 'pbs';
fields = {'Xkp1'; 'ykp1'; 'Zk'; 'primalObj'; 'dualObj'; ...
            'fXkp1'; 'fykp1'; 'fyhatk'; 'vk'; 'deltak'; 'uk'};
prepareRecord();

warning(opt.debug);
out.info = 'MAXNULL/MAXITR'; out.totalTime = -1;
out.Xsol = []; out.ysol = []; out.primalObj = -inf; out.dualObj = inf;
out.solverOutput = []; out.dualGap = inf; out.problem = 0;
tstart = tic; Xhatk = [];

%% Initialization
n = size(C, 1); m = size(A, 1); k = 0; numNull = 0;
uk = opt.u;
options = sdpsettings('verbose', 0, 'solver', 'mosek', ...
    'savesolveroutput', 1);
out.opt = opt;

% Check Assumption 3: A(X)=b --> trace(X)=a
[tf, a, ybar] = checkAssumption3(A, b);
if ~tf
    throw(ME.ASSUM3);
end

% y0
yk = sdpvar(m, 1); % k=0
Zk = C - linearOpT(A, yk);
sol = optimize(diag(Zk) >= 0, -b' * yk, options);
Zk = value(Zk);
yk = value(yk);
yhatk = yk;

% unbounded problem, add more constraints
if sol.problem ~= 0 || any(isnan(Zk), 'all') || any(isnan(yk))
    yk = sdpvar(m, 1); % k=0
    Zk = C - linearOpT(A, yk);
    cons = diag(Zk) >= 0;
    for i = 1 : 2 : n - 1
        cons = [cons Zk([i i+1], [i i+1]) >= 0]; %#ok<AGROW>
    end
    sol = optimize(cons, -b' * yk, options);
    Zk = value(Zk);
    yk = value(yk);
    yhatk = yk;
end

% failed, fallback to randomly initialization
if sol.problem ~= 0 || any(isnan(Zk), 'all') || any(isnan(yk))
    yk = rand(m, 1);
    Zk = C - linearOpT(A, yk);
    [~, lam] = safeSmallestEigs(Zk, 1);
    if size(lam, 1) < 1
        throw(ME.INIT_Y0);
    end
    lam = abs(lam(1, 1));
    yk = yk - lam * ybar;
    Zk = Zk + lam * eye(n);
    yhatk = yk;
end

% initial constraints
[D, lam] = safeSmallestEigs(Zk, opt.s);
if size(D, 2) < opt.s
    throw(ME.OPT_S);
end
fyhatk = b' * yhatk + a * lam(1, 1);
D = D(:, 1:opt.s);
% D = eye(n);

while (opt.maxItr < 0 || k < opt.maxItr) && (numNull < opt.maxNull)
%% direction finding
x = sdpvar(size(D, 2), 1);
X = D * diag(x) * D';
gamma = sdpvar(1, 1);
reg = b - linearOp(A, X);
XZk = sum(X .* Zk, 'all'); % <X, C - A^T(yk)>

trial = 0;
while trial < 5
    cons = [...
        reg' * reg / (2 * uk) + b' * yk + XZk <= gamma, ...
        sum(x, 'all') == a, x >= 0 ...
    ];
    sol = optimize(cons, gamma, options);
    time = toc(tstart); %#ok<NASGU>

    if sol.problem == 0 || sol.problem == 4
        break;
    else
        % Known problems:
        % -4: Solver not applicable, MOSEK reports that the problem is
        % nonconvex. This seems to be a bad numerical condition caused
        % by too small uk.
        % 11: other identified error
        uk = 2 * uk;
        trial = trial + 1;
        continue;
    end
end

if trial >= 5
    out.solverOutput = sol;
    throw(ME.SOLVER_FAILURE);
end
Xkp1 = value(X);
ykp1 = yk + value(reg) / uk;  % y_{k+1}
Zkp1 = C - linearOpT(A, ykp1);
fXkp1 = b' * ykp1 + value(XZk);

[V, lam] = safeSmallestEigs(Zkp1, opt.s);
if size(lam, 1) < opt.s
    throw(ME.OPT_S);
end
fykp1 = b' * ykp1 + a * lam(1, 1);

vk = fykp1 - fyhatk;
deltak = fXkp1 - fyhatk;

% log
[~, ~, primalObj, dualObj] = calculatePrimalDual2( ...
    A, C, b, Xkp1, ykp1, ybar);
dualGap = primalObj - dualObj;
converge1 = abs(dualGap) < opt.epsilon1 * abs(dualObj);
converge2 = abs(deltak) < opt.epsilon2 * abs(dualObj);
fprintf('%d\t%.6e\t%.6e\t%.6e\t%.6e\t%.6e\t%.6e\t%.6e\t%d\t%d\t%d\n', ...
    k, vk, deltak, fyhatk, out.primalObj, out.dualGap, dualGap, ...
    uk, numNull, converge1, converge2);
if opt.record
    out.logData.DSize{k+1} = size(D);
    for i = 1 : size(fields)
        field = fields{i};
        out.logData.(field){k+1} = eval(field);
    end
end

%% Termination
if converge1 && converge2
    yhatk = ykp1;
    Xhatk = Xkp1;
    out.info = 'CONVERGE';
    break;
end

%% Update Solution and Weight
if vk < opt.nu * deltak && deltak > 0
    % null step
    numNull = numNull + 1;
    uk = min([uk * opt.delta2, opt.umax]);
    if vk < 0 && deltak > 0
        uk = min([uk * 2, opt.umax]);
    end
else
    if vk >= opt.nu * deltak && vk > 0
        yhatk = ykp1;  % \hat{y}_{k+1} = y_{k+1}, serious step
        Xhatk = Xkp1;
        fyhatk = fykp1;

        out.primalObj = primalObj;
        out.dualObj = dualObj;
        out.dualGap = out.primalObj - out.dualObj;
        uk = max([uk * opt.delta1, opt.umin]);

        if vk > deltak && abs(dualGap) < 0.1 * abs(dualObj)
            uk = max([uk / 2, opt.umin]);
        end

        numNull = 0;
    end

    % help to lower the dual gap when vk is small
    if abs(out.dualGap) > 0.01 * abs(dualObj) && ...
        vk > 0 && vk < opt.epsilon2 * abs(out.dualObj) * 10 && ...
        abs(deltak) < opt.epsilon2 * abs(out.dualObj) * 10
        uk = max([uk / 1000, 1 / abs(out.dualGap), opt.umin * 100]);
    end
end
yk = ykp1;
Zk = Zkp1;

%% Update Constraints
V = V(:, 1:opt.s);
D = [D, V];  %#ok<AGROW>

k = k + 1;

end % while

%% Termination
[out.Xsol, out.ysol, out.primalObj, out.dualObj] = calculatePrimalDual2(...
    A, C, b, Xhatk, yhatk, ybar);
if size(out.Xsol, 1) > 0
    out.dualGap = out.primalObj - out.dualObj;
    out.primalRes = sum(linearOp(A, out.Xsol) - b, 'all');
end
out.totalTime = toc(tstart);

fprintf('Report:\n');
fprintf('%s after %d sec\n', out.info, out.totalTime);
fprintf('primal Obj. = %.6e\n', out.primalObj);
fprintf('dual Obj. = %.6e\n', out.dualObj);
fprintf('dual Gap = %.6e (%f%%)\n', out.dualGap, ...
    out.dualGap / abs(out.dualObj) * 100);
fprintf('primal Res. = %.6e\n', out.primalRes);

catch ME
    out.info = ME.message;
    out.problem = 1;

    [out.Xsol, out.ysol, out.primalObj, out.dualObj] = calculatePrimalDual2(...
            A, C, b, Xhatk, yhatk, ybar);
    if size(out.Xsol, 1) > 0
        out.dualGap = out.primalObj - out.dualObj;
        out.primalRes = sum(linearOp(A, out.Xsol) - b, 'all');
    end
    out.totalTime = toc(tstart);
    
    if strcmp(opt.debug, 'on')
        rethrow(ME)
    else
        disp(ME.message);
    end
end

endRecord();
warning on;

end
